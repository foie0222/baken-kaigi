name: Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:  # 手動トリガー

permissions:
  id-token: write
  contents: read

jobs:
  # CDKデプロイジョブ
  deploy-cdk:
    name: Deploy CDK Stacks
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: |
      github.ref == 'refs/heads/main' &&
      github.repository == 'foie0222/baken-kaigi' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch')

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ap-northeast-1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: cdk/requirements.txt

      - name: Install CDK
        run: npm install -g aws-cdk@2

      - name: Install Python dependencies
        run: pip install -r requirements.txt
        working-directory: cdk

      - name: CDK Deploy
        run: |
          # ApiStack を先にデプロイ（旧バッチリソース削除）してから
          # BatchStack をデプロイ（新バッチリソース作成）する。
          # 同名 Lambda の競合を防ぐためデプロイ順序を明示的に指定。
          # ※ JraVanServerStack は依存関係により自動的に先にデプロイされる
          cdk deploy BakenKaigiApiStack --context jravan=true --require-approval never
          cdk deploy BakenKaigiBatchStack --context jravan=true --require-approval never
        working-directory: cdk

      - name: Output CDK deployment summary
        run: |
          echo "## CDK Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment completed at $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- AWS Region: ap-northeast-1" >> $GITHUB_STEP_SUMMARY
          echo "- Deploy order: BakenKaigiApiStack → BakenKaigiBatchStack" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployed Stacks" >> $GITHUB_STEP_SUMMARY
          cdk ls --context jravan=true >> $GITHUB_STEP_SUMMARY
        working-directory: cdk

  # AgentCore Runtimeデプロイジョブ
  deploy-agentcore:
    name: Deploy AgentCore Runtime
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: deploy-cdk  # CDKデプロイ後に実行
    if: |
      github.ref == 'refs/heads/main' &&
      github.repository == 'foie0222/baken-kaigi' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch')

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ap-northeast-1

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: backend/agentcore/requirements.txt

      - name: Install AgentCore CLI
        run: pip install bedrock-agentcore-starter-toolkit

      - name: Generate AgentCore config for CI
        working-directory: backend/agentcore
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          AGENTCORE_EXECUTION_ROLE: ${{ secrets.AGENTCORE_EXECUTION_ROLE }}
          AGENTCORE_S3_BUCKET: ${{ secrets.AGENTCORE_S3_BUCKET }}
          AGENTCORE_AGENT_ID: ${{ secrets.AGENTCORE_AGENT_ID }}
        run: |
          # CI環境用の設定ファイルを生成（相対パス使用）
          # 注: AWS関連の値はGitHub Secretsから取得
          cat > .bedrock_agentcore.yaml << EOF
          default_agent: baken_kaigi_cli
          agents:
            baken_kaigi_cli:
              name: baken_kaigi_cli
              language: python
              node_version: '20'
              entrypoint: agent.py
              deployment_type: direct_code_deploy
              runtime_type: PYTHON_3_12
              platform: linux/arm64
              container_runtime: null
              source_path: .
              aws:
                execution_role: ${AGENTCORE_EXECUTION_ROLE}
                execution_role_auto_create: false
                account: '${AWS_ACCOUNT_ID}'
                region: ap-northeast-1
                ecr_repository: null
                ecr_auto_create: false
                s3_path: ${AGENTCORE_S3_BUCKET}
                s3_auto_create: false
                network_configuration:
                  network_mode: PUBLIC
                  network_mode_config: null
                protocol_configuration:
                  server_protocol: HTTP
                observability:
                  enabled: true
                lifecycle_configuration:
                  idle_runtime_session_timeout: null
                  max_lifetime: null
              bedrock_agentcore:
                agent_id: ${AGENTCORE_AGENT_ID}
                agent_arn: arn:aws:bedrock-agentcore:ap-northeast-1:${AWS_ACCOUNT_ID}:runtime/${AGENTCORE_AGENT_ID}
                agent_session_id: null
              codebuild:
                project_name: null
                execution_role: null
                source_bucket: null
              memory:
                mode: NO_MEMORY
                memory_id: null
                memory_arn: null
                memory_name: null
                event_expiry_days: 30
                first_invoke_memory_check_done: false
                was_created_by_toolkit: false
              identity:
                credential_providers: []
                workload: null
              aws_jwt:
                enabled: false
                audiences: []
                signing_algorithm: ES384
                issuer_url: null
                duration_seconds: 300
              authorizer_configuration: null
              request_header_configuration: null
              oauth_configuration: null
              api_key_env_var_name: null
              api_key_credential_provider_name: null
              is_generated_by_agentcore_create: false
          EOF
          # heredocの先頭スペースを削除
          sed -i 's/^          //' .bedrock_agentcore.yaml

      - name: Deploy AgentCore Runtime
        working-directory: backend/agentcore
        run: |
          set -euo pipefail

          echo "Deploying AgentCore Runtime..."
          if ! agentcore launch --auto-update-on-conflict; then
            echo "::error::agentcore launch failed"

            # デバッグ情報を収集
            echo "Collecting debug information..."
            agentcore status --verbose || true

            exit 1
          fi

      - name: Verify deployment
        working-directory: backend/agentcore
        run: |
          set -euo pipefail

          echo "Verifying AgentCore deployment..."
          if ! agentcore status; then
            echo "::error::agentcore status failed"
            exit 1
          fi

      - name: Output AgentCore deployment summary
        run: |
          echo "## AgentCore Runtime Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Agent: baken_kaigi_cli" >> $GITHUB_STEP_SUMMARY
          echo "- Region: ap-northeast-1" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment completed at $(date)" >> $GITHUB_STEP_SUMMARY

  # EC2 (JRA-VAN API) デプロイジョブ
  deploy-ec2:
    name: Deploy JRA-VAN API to EC2
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: deploy-cdk  # CDKデプロイ後に実行（S3バケット作成が必要）
    if: |
      github.ref == 'refs/heads/main' &&
      github.repository == 'foie0222/baken-kaigi' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch')

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # github.event.before との差分取得に必要

      - name: Check jravan-api changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "Manual trigger: deploying regardless of changes"
          elif git diff --name-only "${{ github.event.before }}" "${{ github.sha }}" -- 'jravan-api/' | grep -qE '\.(py|txt)$'; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "jravan-api changes detected"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
            echo "No jravan-api changes, skipping deploy"
          fi

      - name: Configure AWS credentials
        if: steps.changes.outputs.changed == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ap-northeast-1

      - name: Get deployment parameters from CloudFormation
        if: steps.changes.outputs.changed == 'true'
        id: cfn
        run: |
          EXPORTS=$(aws cloudformation list-exports --query 'Exports' --output json)

          INSTANCE_ID=$(echo "$EXPORTS" | jq -r '.[] | select(.Name=="JraVanInstanceId") | .Value')
          BUCKET_NAME=$(echo "$EXPORTS" | jq -r '.[] | select(.Name=="JraVanDeployBucketName") | .Value')

          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "null" ]; then
            echo "::error::JraVanInstanceId not found in CloudFormation exports"
            exit 1
          fi
          if [ -z "$BUCKET_NAME" ] || [ "$BUCKET_NAME" = "null" ]; then
            echo "::error::JraVanDeployBucketName not found in CloudFormation exports"
            exit 1
          fi

          echo "instance_id=$INSTANCE_ID" >> "$GITHUB_OUTPUT"
          echo "bucket_name=$BUCKET_NAME" >> "$GITHUB_OUTPUT"
          echo "Instance ID: $INSTANCE_ID"
          echo "Bucket: $BUCKET_NAME"

      - name: Package and upload to S3
        if: steps.changes.outputs.changed == 'true'
        run: |
          cd jravan-api
          zip -r /tmp/jravan-api-deploy.zip *.py requirements.txt \
            -x "tests/*" "__pycache__/*" ".env" ".env.*"
          aws s3 cp /tmp/jravan-api-deploy.zip \
            "s3://${{ steps.cfn.outputs.bucket_name }}/deploy/jravan-api-${GITHUB_SHA:0:8}.zip"

      - name: Deploy via SSM SendCommand
        if: steps.changes.outputs.changed == 'true'
        id: ssm
        run: |
          S3_KEY="deploy/jravan-api-${GITHUB_SHA:0:8}.zip"
          BUCKET_NAME="${{ steps.cfn.outputs.bucket_name }}"
          INSTANCE_ID="${{ steps.cfn.outputs.instance_id }}"

          # EC2にはAWS CLIもAWS.Tools.S3も入っていないため、プリサインドURLで渡す
          PRESIGNED_URL=$(aws s3 presign "s3://${BUCKET_NAME}/${S3_KEY}" --expires-in 600)

          # PowerShellデプロイスクリプトを生成（単一引用heredocでbash展開を防止）
          cat > /tmp/deploy.ps1 << 'PSEOF'
          Set-StrictMode -Version Latest
          $ErrorActionPreference = 'Stop'

          # 変数定義（__PRESIGNED_URL__ はpython3で置換）
          $presignedUrl = '__PRESIGNED_URL__'
          $deployDir = 'C:\jravan-api'
          $tempZip = 'C:\setup\jravan-api-deploy.zip'
          $timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'
          $backupDir = "C:\jravan-api\backup-$timestamp"

          # SSMセッションではPATHが不完全なため、マシン環境変数から再構築
          $env:Path = [System.Environment]::GetEnvironmentVariable('Path','Machine') + ';' + [System.Environment]::GetEnvironmentVariable('Path','User')

          # プリサインドURLでS3からダウンロード（外部依存なし）
          Write-Output "Downloading deploy artifact..."
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
          Invoke-WebRequest -Uri $presignedUrl -OutFile $tempZip -UseBasicParsing

          # バックアップ作成
          Write-Output "Creating backup at $backupDir"
          New-Item -ItemType Directory -Force -Path $backupDir | Out-Null
          Get-ChildItem -Path $deployDir -Filter '*.py' | Copy-Item -Destination $backupDir
          if (Test-Path "$deployDir\requirements.txt") { Copy-Item "$deployDir\requirements.txt" -Destination $backupDir }

          # 古いバックアップを3世代まで保持
          Get-ChildItem -Path $deployDir -Directory -Filter 'backup-*' | Sort-Object Name -Descending | Select-Object -Skip 3 | Remove-Item -Recurse -Force

          # requirements.txt変更チェック（pip install判定用）
          $reqChanged = $false
          $tempExtract = 'C:\setup\jravan-api-extract'
          if (Test-Path $tempExtract) { Remove-Item -Recurse -Force $tempExtract }
          Expand-Archive -Path $tempZip -DestinationPath $tempExtract -Force
          if (Test-Path "$deployDir\requirements.txt") {
            $oldHash = (Get-FileHash "$deployDir\requirements.txt").Hash
            $newHash = (Get-FileHash "$tempExtract\requirements.txt").Hash
            if ($oldHash -ne $newHash) { $reqChanged = $true }
          } else {
            $reqChanged = $true
          }

          # ファイル展開（上書き）
          Write-Output "Extracting files to $deployDir"
          Copy-Item -Path "$tempExtract\*" -Destination $deployDir -Recurse -Force
          Remove-Item -Recurse -Force $tempExtract

          # requirements変更時のみpip install
          if ($reqChanged) {
            Write-Output 'requirements.txt changed, running pip install...'
            pip install -r "$deployDir\requirements.txt"
          } else {
            Write-Output 'requirements.txt unchanged, skipping pip install'
          }

          # スケジュールタスク再起動（JraVanApiはTask Schedulerで管理）
          Write-Output 'Restarting JraVanApi task...'
          $task = Get-ScheduledTask -TaskName 'JraVanApi' -ErrorAction SilentlyContinue
          if (-not $task) {
            Write-Output 'ERROR: Scheduled task JraVanApi not found'
            exit 1
          }
          if ($task.State -eq 'Running') {
            Stop-ScheduledTask -TaskName 'JraVanApi'
          }
          Start-Sleep -Seconds 2
          # ポート8000を使用しているプロセスのみを停止（LISTENに限定）
          $portPids = (Get-NetTCPConnection -LocalPort 8000 -State Listen -ErrorAction SilentlyContinue).OwningProcess | Sort-Object -Unique
          foreach ($procId in $portPids) {
            Write-Output "Stopping process $procId (using port 8000)"
            Stop-Process -Id $procId -Force -ErrorAction SilentlyContinue
          }
          Start-Sleep -Seconds 2
          Start-ScheduledTask -TaskName 'JraVanApi'
          Start-Sleep -Seconds 5

          # ヘルスチェック（最大30秒リトライ）
          Write-Output 'Running health check...'
          $maxRetries = 10
          $retryCount = 0
          $healthy = $false
          while ($retryCount -lt $maxRetries) {
            try {
              $response = Invoke-WebRequest -Uri 'http://localhost:8000/health' -TimeoutSec 5 -UseBasicParsing
              if ($response.StatusCode -eq 200) {
                $healthy = $true
                Write-Output 'Health check passed'
                break
              }
            } catch {
              Write-Output "Health check attempt $($retryCount + 1)/$maxRetries failed: $($_.Exception.Message)"
            }
            $retryCount++
            Start-Sleep -Seconds 3
          }

          if (-not $healthy) {
            Write-Output 'Health check failed, rolling back...'
            Copy-Item -Path "$backupDir\*" -Destination $deployDir -Force
            Stop-ScheduledTask -TaskName 'JraVanApi' -ErrorAction SilentlyContinue
            $portPids = (Get-NetTCPConnection -LocalPort 8000 -State Listen -ErrorAction SilentlyContinue).OwningProcess | Sort-Object -Unique
            foreach ($procId in $portPids) {
              Write-Output "Stopping process $procId (using port 8000)"
              Stop-Process -Id $procId -Force -ErrorAction SilentlyContinue
            }
            Start-Sleep -Seconds 2
            Start-ScheduledTask -TaskName 'JraVanApi'
            Write-Output 'Rollback complete'
            exit 1
          }

          # クリーンアップ
          Remove-Item -Force $tempZip
          Write-Output 'Deployment successful'
          PSEOF

          # heredocインデント除去 + プレースホルダー置換 + JSON変換
          sed -i 's/^          //' /tmp/deploy.ps1
          echo "$PRESIGNED_URL" > /tmp/presigned_url.txt
          python3 << 'PYEOF'
          import json
          script = open('/tmp/deploy.ps1').read()
          url = open('/tmp/presigned_url.txt').read().strip()
          script = script.replace('__PRESIGNED_URL__', url)
          lines = script.splitlines()
          json.dump({'commands': lines}, open('/tmp/ssm-params.json', 'w'))
          PYEOF

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunPowerShellScript" \
            --timeout-seconds 300 \
            --parameters file:///tmp/ssm-params.json \
            --query 'Command.CommandId' --output text)

          echo "command_id=$COMMAND_ID" >> "$GITHUB_OUTPUT"
          echo "SSM Command ID: $COMMAND_ID"

      - name: Wait for SSM command completion
        if: steps.changes.outputs.changed == 'true'
        run: |
          COMMAND_ID="${{ steps.ssm.outputs.command_id }}"
          INSTANCE_ID="${{ steps.cfn.outputs.instance_id }}"
          MAX_WAIT=300  # 5分
          ELAPSED=0

          echo "Waiting for SSM command $COMMAND_ID to complete..."

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' --output text 2>/dev/null || echo "Pending")

            case "$STATUS" in
              "Success")
                echo "Command completed successfully"
                # 標準出力を表示
                aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --query 'StandardOutputContent' --output text
                exit 0
                ;;
              "Failed"|"Cancelled"|"TimedOut")
                echo "::error::SSM command $STATUS"
                echo "--- Standard Output ---"
                aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --query 'StandardOutputContent' --output text || true
                echo "--- Standard Error ---"
                aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --query 'StandardErrorContent' --output text || true
                exit 1
                ;;
              *)
                sleep 10
                ELAPSED=$((ELAPSED + 10))
                ;;
            esac
          done

          echo "::error::Timed out waiting for SSM command"
          exit 1

      - name: Output EC2 deployment summary
        if: always() && steps.changes.outputs.changed == 'true'
        run: |
          echo "## EC2 (JRA-VAN API) Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Instance: ${{ steps.cfn.outputs.instance_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- S3 Artifact: s3://${{ steps.cfn.outputs.bucket_name }}/deploy/jravan-api-${GITHUB_SHA:0:8}.zip" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment completed at $(date)" >> $GITHUB_STEP_SUMMARY
